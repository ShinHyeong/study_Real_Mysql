# 10-1 통계정보
 
##	1. 테이블 및 인덱스 통계 정보
    통계 정보가 잘 업데이트 되어야 옵티마이저가 실행계획을 제대로 짠다. 
###    1-1 MySQL 서버의 통계 정보
        5.6버전부터는 각 테이블의 통계 정보를 mysql 데이터베이스의 innodb_index_stats 테이블과 innodb_table_stats테이블로 관리할 수 있게 개선.
        서버가 재시작해도 통계정보 유지가능.
        테이블 생성시 STATS_PERSISTENT 옵션설정을 한다. 아래는 관련 시스템 변수옵션들.

        - 시스템 변수 의미
		    innodb_stats_persistent : 테이블생성 시 통계정보 저장여부 설정. 디폴트값은 1(영구저장). 0(단기저장)
![innodb_index_stats 시스템변수들](https://github.com/juyeong-repo/Real_Mysql/assets/35548848/242a401e-1733-4638-8a98-9ac99e7b8dcb)
![innodb_index_stats 시스템변수들2](https://github.com/juyeong-repo/Real_Mysql/assets/35548848/2bbc096f-84d2-4664-b970-d191a3d873bf)
            정확한 통계정보를 수집하고자 한다면 innodb_stats_persistent_sample_page 시스템변수값을 높게 설정하면 된다. 
            그러나 그렇게 하면 통계 정보 수집기간이 길어지기 때문에 유의할 것.
###    1-2 히스토그램
        8.0버전부터 칼럼의 데이터 분포도를 참조할 수 있다.
        
        - 히스토그램 정보 수집 및 삭제
            서버시작할 때 information_schma 데이터베이스의 column_statistic테이블로 로드한다.
            ANALYZE TABLE ~ UPDATE HISTOGRAM 명령어 이용. 수동으로 수집관리한다.수집한 정보는 시스템 딕셔너리에 저장.
            column_statistic테이블을 SELECT해서 실제 히스토그램 정보를 조회할 수 있다.
		   
        1. 수집
            -information_schma.column_statistic 테이블의 HISTOGRAM칼럼 가진 필드
                * sampling-rate : 히스토그램 정보를 수집하기 위해 스캔한 페이지 비율을 저장. 
                    샘플링 비율이 높을수록 정확하지만 테이블 스캔값이 높으면 시스템자원을 많이 소모하기 때문에 부하가 걸릴 수 있다.
                * histogram-rate : 히스토그램의 종류 저장
                * number-of-buckets-specified : 히스토그램을 생성할 때 설정했던 버킷의 개수 저장. 기본값은 100개. 최대 1024개.

            - 히스토그램 타입
                1. Singleton(싱글톤) 히스토그램 : 칼럼값 개별로 레코드건수관리. Value-Based 히스토그램. 도수분포.
                    칼럼이 가지는 값별로 버킷이 할당. 각 버킷이 칼럼 값과 발생 빈도의 비율값을 가진다.
                    ENUM타입의 칼럼이 있는경우 적절함.
                2. Equi-Height(높이 균형) 히스토그램 : 칼럼값의 범위를 균등한 갯수로 구분해서 관리. Height-Balanced 히스토그램.
                    각 버킷이 범위 시작값과 마지막 값, 발생 빈도율, 버킷에 포함된 유니크한 값 개수 -> 총 4개의 값을 가진다.
                * 버킷 : 히스토그램은 버킷단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리된다.

        2. 삭제
            삭제 시 테이블의 데이터를 참조하지 않고 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리처리성능에 영향없이 즉시완료된다.
            * OPTIMIZER_SWITCH : 히스토그램을 삭제하지 않고 옵티마이저가 히스토그램을 사용하지 않게 설정하는 변수(GLOBAL로 변경해서 사용)
                GLOBAL로 설정하게되면 condition_fanout_filter 옵션에 영향받는 다른 최적화기능도 비활성화 된다.
		
        - 히스토그램 용도
            특정 범위의 데이터가 많고 적음을 식별가능. 이는 쿼리의 성능에 상당한 영향을 미칠 수 있다.
            예시에 든 것처럼 테이블 조인순서에 따라 조인을 해야하는 건수차이가 큰테 이는 히스토그램정보를 통해 데이터 분포를 파악하고 있기에 가능하다.
            히스토그램의 정보로 인해 옵티마이저가 어떤 테이블을 먼저 읽어야 조인횟수를 줄일 수 있는지 정확하게 파악가능하다.

        - 히스토그램과 인덱스
            인덱스 다이브 : 서버에서 쿼리의 실행 계획을 수립할 때 사용가능한 인덱스들로부터 조건절에 일치하는 레코드 건수 파악 후 최선의 실행계획을 선택한다.
                이때 조건절에 일치하는 레코드 건수 예측을 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링 해서 살펴보는 것.

            인덱스된 칼럼에 대해 히스토그램 정보를 수집하는게 좋은가?
            > 실제 서버에서는 인덱스 다이브를 통해 직접 수집한 정보를 황용한다. 그래서 히스토그램은 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조한다.

        - 코스트 모델
            : 8.0버전부터 칼럼의 데이터 분포를 위한 히스토그램과 각 인덱스별 메모리에 적재된 페이지 비율을 관리. 이는 옵티마이저의 실행계획수립에 사용된다.
            - 코스트 모델관련 테이블
                * server_cost : 인덱스를 찾고 레코들르 비교해 임시 테이블 처리에 대한 비용관리
                * engine_cost : 레코드를 가진 데이터 페이지를 가져오는데 필요한 비용관리

                * 공통 테이블 칼럼
![코스트모델 사용테이블 공통칼럼](https://github.com/juyeong-repo/Real_Mysql/assets/35548848/ee931c6c-5138-4bfe-9e1a-bbf5e0429c82)
                    engine_name : 스토리지 엔진별로 각 단위 작업의 비용 설정. 해당 스토리지 엔진의 비용으로 값을 적용하는게 디폴트 값.
                    그래서 엔진마다 단위 작업의 비용을 다르게 설정하려면 해당 칼럼을 이용하면 된다.
                    device_type : 디스크 타입설정하는 칼럼이나 8.0에서는 사용하지 않아서 0으로만 설정가능.
                * 8.0 버전 코스트 모델에서 지원하는 작업단위들
![코스트모델 단위작업](https://github.com/juyeong-repo/Real_Mysql/assets/35548848/94472fba-df85-48c9-8ff8-8ab232c16ab4)
                    row_evaluate_cost : 스토리지 엔진이 반환한 레코드가 쿼리의 조건에 일치하는지를 평가하는 작업단위. 
                        해당 값이 증가 -> 많은 레코드를 처리하는 쿼리의 비용이 높아진다.
                        해당 값이 감소 -> 상대적으로 적은 수의 레코드를 처리하는 쿼리 비용이 낮아진다.
                    key_compare_cost : 키 값의 비교 작업에 필요한 비용을 의미. 값이 증가할수록 쿼리의 비용이 높아진다.

                : 각 단위작업에 설정되는 비용값이 커지고 작아지냐에 따라 어떤 실행계획의 비용이 커지고 작아질 수 있다. 코스트 모델에서 가장 중요한 것으로
                아래의 내용은 각 단위작업의 비용이 변경되면 예상되는 결과들이다.
![코스트모델 단위작업 예상결과](https://github.com/juyeong-repo/Real_Mysql/assets/35548848/0a5b25e9-bb67-4ae9-acbf-cacb54c4e9a5)
			
# 10-2 실행 계획 확인

##	1. 실행 계획 출력 포맷
    : FORMAT 옵션을 이용해 실행 계획 표시 방법을 JSON이나 TREE, 테이블 형태 중 선택가능.
##	2. 쿼리 실행 시간 확인
    : EXPLAN ANALYZE 명령어로 확인가능하다. TREE포맷의 실행 계획에서는 들여쓰기는 호출순서를 의미. 
	  EXPLAN 명령어와 달리 실행계획 + 실제 쿼리 실행하고 사용도니 실행계획과 소용된 시간을 보여준다. 쿼리가 까다롭다면 EXPLAN 명령으로 먼저 실행계획 확인 후 튜닝하고 EXPLAN ANALYZE 명령어를 실행하자
        들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행되며, 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행된다.

![실행계획 실행순서 보여주기](https://github.com/juyeong-repo/Real_Mysql/assets/35548848/ad876827-2f56-4542-9656-48f5df71ce95)

    : EXPLAN ANALYZE 결과
        - actual time : 실제 소요시간. 표시되는 값이 총 2개인데, 첫번째숫자는 첫번째 레코드에서 가져오는데 걸린 평균시간. 두번째는 마지막 레코드를 가져오는데 걸린시간.
        - rows : 레코드 건수.
        - loops : 반복 횟수. 
